# Feature 0001: Trading Engine Backend System

## Brief Description

Build a standalone Python-based high-frequency gold scalping trading engine that executes 15-30 trades per day during London/NY sessions. The system uses pure technical analysis (EMA, RSI, support/resistance) on M1/M5 timeframes to generate signals, executes trades via MetaTrader 5 API with sub-2-second latency, and implements multi-layered risk management including circuit breakers, time-based exits, and position sizing rules. Target: 65%+ win rate with 0.25-0.40% stops and 1:1.2 risk-reward ratios.

## Files and Functions to Create

### Project Structure
```
trading-engine/
├── config/
│   ├── __init__.py
│   ├── config.yaml                    # Base configuration template
│   └── config_loader.py               # YAML config loader with env overrides
├── src/
│   ├── __init__.py
│   ├── main.py                        # Entry point, orchestrates all modules
│   ├── market_data/
│   │   ├── __init__.py
│   │   ├── mt5_connector.py           # MT5 API connection and data fetching
│   │   ├── candle_processor.py        # OHLC data processing and validation
│   │   └── indicators.py              # EMA, RSI, ATR calculations
│   ├── signals/
│   │   ├── __init__.py
│   │   ├── structure_analyzer.py       # M5 market structure identification
│   │   ├── momentum_analyzer.py       # M1 momentum confirmation
│   │   └── signal_generator.py        # Combines structure + momentum, generates signals
│   ├── risk/
│   │   ├── __init__.py
│   │   ├── position_sizer.py          # Calculates lot size based on risk %
│   │   ├── risk_validator.py          # Pre-trade validation (spread, ATR, equity)
│   │   └── circuit_breaker.py         # Multi-criteria halt system
│   ├── execution/
│   │   ├── __init__.py
│   │   ├── order_executor.py          # Places orders via MT5 API
│   │   └── order_validator.py         # Validates order parameters before execution
│   ├── position/
│   │   ├── __init__.py
│   │   ├── position_manager.py        # Monitors open positions, manages exits
│   │   └── exit_strategy.py           # Multi-layered exit logic (TP, SL, time, momentum)
│   ├── session/
│   │   ├── __init__.py
│   │   ├── session_manager.py          # Time-based trading windows (GMT)
│   │   └── volatility_filter.py       # ATR-based market condition filtering
│   ├── analytics/
│   │   ├── __init__.py
│   │   ├── trade_recorder.py          # Records signals and trades to SQLite
│   │   ├── performance_tracker.py      # Calculates win rate, P&L, metrics
│   │   └── database.py                # SQLite schema and operations
│   └── utils/
│       ├── __init__.py
│       ├── logger.py                  # Structured logging with rotation
│       └── types.py                   # Type definitions (Signal, Trade, Position, etc.)
├── tests/
│   └── (test files for each module)
├── requirements.txt                   # Python dependencies
├── README.md
└── .env.example                       # Environment variable template
```

### Core Functions and Classes

#### `src/main.py`
- `main()`: Entry point, initializes all modules, runs execution loop
- `ExecutionLoop`: 30-second cycle orchestrator
- `initialize_system()`: Sets up MT5 connection, loads config, initializes database

#### `src/market_data/mt5_connector.py`
- `MT5Connector` class:
  - `connect()`: Establishes MT5 connection with credentials
  - `get_candles(symbol, timeframe, count)`: Fetches M1/M5 OHLC data
  - `get_current_price(symbol)`: Gets bid/ask and spread
  - `get_account_info()`: Retrieves equity, balance, margin
  - `disconnect()`: Closes MT5 connection
  - `is_connected()`: Connection status check

#### `src/market_data/indicators.py`
- `calculate_ema(prices, period)`: Exponential Moving Average calculation
- `calculate_rsi(prices, period)`: Relative Strength Index (14-period default)
- `calculate_atr(high, low, close, period)`: Average True Range (14-period default)
- `identify_swing_points(candles, lookback)`: Finds swing highs/lows on M5 (last 10 candles)
- `detect_trend(ema_values)`: Determines bullish/bearish trend from EMA21 slope

#### `src/signals/structure_analyzer.py`
- `StructureAnalyzer` class:
  - `analyze_m5_structure(candles, ema21, swing_points)`: Identifies market structure
    - Returns: `{trend: 'bullish'|'bearish'|'neutral', support_level: float, resistance_level: float, structure_type: str}`
  - `is_price_near_level(price, level, tolerance)`: Checks if price is near swing high/low
  - `is_pullback_to_ema(price, ema21, tolerance)`: Detects pullback to EMA21

#### `src/signals/momentum_analyzer.py`
- `MomentumAnalyzer` class:
  - `analyze_m1_momentum(candles, rsi)`: Checks for 3 consecutive candles in signal direction
    - Returns: `{direction: 'buy'|'sell'|'none', strength: float, body_ratio: float}`
  - `has_strong_bodies(candles, min_body_ratio)`: Validates candle body strength
  - `check_volume_spike(candles)`: Optional volume confirmation (if available)

#### `src/signals/signal_generator.py`
- `SignalGenerator` class:
  - `generate_signal(m5_data, m1_data, indicators)`: Main signal generation logic
    - Algorithm:
      1. Get M5 structure from `StructureAnalyzer`
      2. Get M1 momentum from `MomentumAnalyzer`
      3. Check RSI confirmation (M1 oversold/overbought with M5 supporting)
      4. Validate entry conditions (all must be true):
         - M5 shows bullish/bearish structure
         - M1 shows 3 consecutive candles in signal direction
         - Price near M5 swing high/low OR pulled back to EMA21
         - RSI confirms (M1 RSI < 30 for buy with M5 RSI > 50, or M1 RSI > 70 for sell with M5 RSI < 50)
      5. Determine entry type: Structure Break, Pullback Continuation, or Liquidity Sweep
      6. Calculate confidence score (0-100)
    - Returns: `Signal(direction, entry_type, confidence, timestamp, reason)`
  - `validate_entry_conditions()`: Checks all required conditions are met

#### `src/risk/position_sizer.py`
- `PositionSizer` class:
  - `calculate_lot_size(equity, risk_percent, stop_distance_points, symbol)`: Position sizing
    - Formula: `lots = (equity × risk_percent) / (stop_distance_points × point_value_per_lot)`
    - Constraints: min 0.01, max 0.30 lots
    - Returns: rounded lot size
  - `calculate_stop_distance(entry_price, stop_percent)`: Converts % stop to points
    - Range: 0.25-0.40% (preferred 0.30%)
    - Adds 3-point safety buffer

#### `src/risk/risk_validator.py`
- `RiskValidator` class:
  - `validate_signal(signal, market_data, account_info, config)`: Pre-trade validation
    - Checks: spread limits (0.25-0.30 points), ATR range (6-12 points), equity sufficient, no existing position
    - Returns: `{valid: bool, reason: str}`
  - `check_spread(spread, session_type)`: Validates spread within limits
  - `check_atr(atr_value, atr_average)`: Validates ATR in range, checks for spikes
  - `check_equity(equity, required_margin)`: Ensures sufficient equity

#### `src/risk/circuit_breaker.py`
- `CircuitBreaker` class:
  - `check_halts(trade_history, daily_pnl)`: Evaluates halt conditions
    - Triggers: 3 consecutive losses, 5 losses in 7 trades, -3% daily drawdown, 4 stop-outs in 5 trades
    - Returns: `{halted: bool, reason: str, duration_minutes: int}`
  - `adjust_risk_parameters(loss_count)`: Graduated response
    - After 1 loss: confidence threshold 70%
    - After 2 losses: risk 0.3%, confidence 75%, tighter spread
    - After 3 losses: halt 60 minutes
  - `reset_conditions(trade_history)`: Checks reset (2 consecutive wins, 1.5R+ win)
  - `get_current_state()`: Returns current halt status and adjusted parameters

#### `src/execution/order_executor.py`
- `OrderExecutor` class:
  - `place_order(signal, lot_size, stop_loss, take_profit, symbol)`: Executes trade via MT5
    - Uses `mt5.order_send()` with market order
    - Validates slippage tolerance (2 points max)
    - Returns: `{success: bool, ticket: int, error: str}`
  - `calculate_take_profit(entry_price, stop_loss, risk_reward_ratio, direction)`: TP calculation
    - Preferred: 1.2:1 R:R, minimum 1:1, stretch 1.5:1
  - `validate_order_parameters()`: Pre-execution validation

#### `src/position/position_manager.py`
- `PositionManager` class:
  - `monitor_positions()`: Checks open positions every cycle
  - `update_stop_loss(ticket, new_sl)`: Moves stop loss (breakeven protection)
  - `partial_close(ticket, percent)`: Closes portion of position
    - At 0.20% profit: close 50%, move SL to entry
    - At 0.35% profit: close 30% more, let 20% run
  - `force_close(ticket, reason)`: Emergency close (time limit, circuit breaker)
  - `get_open_positions()`: Returns list of active positions

#### `src/position/exit_strategy.py`
- `ExitStrategy` class:
  - `evaluate_exits(position, market_data, indicators)`: Multi-layered exit logic
    - Exit hierarchy (first condition met):
      1. Take Profit hit: Close at 1.2× stop loss distance
      2. Time-based: Force close at 15 minutes regardless of P&L
      3. Stop Loss hit: Fixed stop at 0.30-0.40% below entry
      4. Momentum reversal: M1 shows 3 consecutive opposite candles
      5. Breakeven protection: Move SL to entry + 2 points when position reaches 0.15% profit
    - Returns: `{should_exit: bool, exit_type: str, action: str, exit_reason: str | None}`
      - `exit_reason` is only set when `should_exit = true` (position is closed)
      - For stop loss adjustments (action = "adjust_sl"), `should_exit = false` and `exit_reason = None`

#### `src/session/session_manager.py`
- `SessionManager` class:
  - `is_trading_window(current_time_gmt)`: Checks if current time is in trading window
    - Prime sessions: 08:00-09:30, 13:00-15:00, 14:30-15:30 GMT
    - Acceptable: 09:30-13:00, 15:30-17:00 GMT
    - Avoid: 00:00-07:00, 18:00-24:00, Friday after 16:00
  - `get_session_type(current_time)`: Returns 'prime', 'acceptable', or 'closed'
  - `get_risk_multiplier(session_type)`: Returns 1.0 for prime, 0.7-0.8 for acceptable
  - `get_next_window()`: Returns next trading window start time

#### `src/session/volatility_filter.py`
- `VolatilityFilter` class:
  - `validate_atr(atr_value, atr_average)`: ATR filtering
    - Minimum: 6.0 points (reject if below)
    - Maximum: 12.0 points (reject if above)
    - Optimal: 8-11 points
    - Spike detection: Reject if ATR > 1.8× 20-period average
  - `is_market_choppy(atr, atr_average)`: Determines if market is too choppy
  - `is_market_too_volatile(atr)`: Checks if volatility too high for tight stops

#### `src/analytics/database.py`
- `Database` class:
  - `initialize_schema()`: Creates SQLite tables
    - Tables: `signals`, `trades`, `sessions`, `circuit_breaker_events`
  - `record_signal(signal)`: Stores generated signal
  - `record_trade(trade)`: Stores executed trade with P&L
  - `get_trade_history(limit)`: Retrieves recent trades for circuit breaker
  - `get_session_performance(date)`: Aggregates session metrics

#### `src/analytics/trade_recorder.py`
- `TradeRecorder` class:
  - `record_signal(signal)`: Logs signal to database
  - `record_trade_entry(ticket, signal, entry_price, lot_size)`: Records trade start
  - `record_trade_exit(ticket, exit_price, pnl, hold_time, exit_reason)`: Records trade end
  - `update_trade_partial_close(ticket, closed_percent, remaining_lots)`: Updates position after partial exit

#### `src/analytics/performance_tracker.py`
- `PerformanceTracker` class:
  - `calculate_win_rate(trades, period)`: Win rate over last N trades
  - `calculate_daily_pnl(date)`: Daily profit/loss
  - `calculate_average_hold_time(trades)`: Average trade duration
  - `get_performance_metrics()`: Returns all key metrics
  - `generate_report()`: Creates performance summary

#### `src/utils/logger.py`
- `setup_logger(name, log_dir, level)`: Configures structured logging
- `rotate_logs()`: Daily rotation, keeps 30 days, compresses >7 days
- Log levels: DEBUG (market data, indicators), INFO (trades, decisions), WARNING (near-misses, limits), ERROR (failures, API errors)

#### `src/utils/types.py`
- Type definitions:
  - `Signal`: `{direction: str, entry_type: str, confidence: float, timestamp: datetime, reason: str, price: float}`
  - `Trade`: `{ticket: int, symbol: str, direction: str, entry_price: float, lot_size: float, stop_loss: float, take_profit: float, entry_time: datetime, exit_time: datetime, pnl: float, exit_reason: str}`
  - `Position`: `{ticket: int, symbol: str, type: str, volume: float, price_open: float, sl: float, tp: float, profit: float, time: datetime}`
  - `MarketData`: `{m1_candles: list, m5_candles: list, current_price: float, spread: float, indicators: dict}`

#### `config/config_loader.py`
- `ConfigLoader` class:
  - `load_config(env)`: Loads YAML config with environment overrides
  - `get_mt5_credentials()`: Retrieves MT5 login credentials
  - `get_risk_parameters()`: Returns risk per trade, stop loss range, R:R ratio
  - `get_trading_sessions()`: Returns enabled trading windows
  - `get_circuit_breaker_thresholds()`: Returns halt conditions

## Algorithms Explained

### Signal Generation Algorithm (Structure Break Momentum)

**Step 1: M5 Structure Analysis**
1. Fetch last 20 M5 candles
2. Calculate EMA21 on M5 close prices
3. Identify swing highs/lows from last 10 M5 candles
4. Determine trend: If price > EMA21 and EMA21 is rising → bullish, else if price < EMA21 and EMA21 is falling → bearish
5. Identify support (swing low) and resistance (swing high) levels

**Step 2: M1 Momentum Confirmation**
1. Fetch last 10 M1 candles
2. Calculate RSI14 on M1
3. Check for 3 consecutive candles in same direction:
   - For buy: 3 consecutive green candles with bodies > 60% of range
   - For sell: 3 consecutive red candles with bodies > 60% of range
4. Calculate momentum strength: average body size / average candle range

**Step 3: Entry Condition Validation (ALL must be true)**
1. M5 structure matches signal direction (bullish for buy, bearish for sell)
2. M1 shows 3 consecutive candles in signal direction with strong bodies
3. Price condition (one of):
   - Near M5 swing high/low (within 5 points)
   - Pulled back to M5 EMA21 (within 3 points)
   - Liquidity sweep: wick below swing low then immediate recovery
4. RSI confirmation:
   - Buy: M1 RSI < 30 (oversold) AND M5 RSI > 50 (supporting bullish)
   - Sell: M1 RSI > 70 (overbought) AND M5 RSI < 50 (supporting bearish)

**Step 4: Entry Type Classification**
- Structure Break: Price breaks M5 resistance/support with M1 momentum
- Pullback Continuation: Price at EMA21, bounces with M1 confirmation
- Liquidity Sweep: Price wicks below swing low, immediately recovers

**Step 5: Confidence Calculation**
- Base: 60% if all conditions met
- +10% if volume spike detected
- +10% if strong momentum (body ratio > 70%)
- +10% if price exactly at key level (swing/EMA)
- +10% if RSI is extreme (<25 or >75)
- Max: 100%

### Position Sizing Algorithm

**Inputs:** Equity, risk_percent (0.5%), stop_distance_percent (0.30%), symbol (XAUUSD)

**Steps:**
1. Calculate stop distance in points: `stop_points = entry_price × stop_percent / 100`
2. Add safety buffer: `stop_points += 3`
3. Calculate point value per lot for XAUUSD (typically $0.01 per point per 0.01 lot)
4. Calculate risk amount: `risk_amount = equity × risk_percent / 100`
5. Calculate lot size: `lots = risk_amount / (stop_points × point_value_per_lot)`
6. Apply constraints: min 0.01, max 0.30 lots
7. Round to nearest 0.01 lot

### Exit Strategy Algorithm (Multi-Layered)

**Evaluation Order (First condition met = exit):**

1. **Take Profit Check:**
   - Calculate TP distance: `tp_distance = stop_loss_distance × risk_reward_ratio (1.2)`
   - If current profit >= TP distance → Close position, record exit_reason = "take_profit"

2. **Time Limit Check:**
   - Calculate hold time: `hold_time = current_time - entry_time`
   - If hold_time >= 15 minutes → Force close, exit_reason = "time_limit"
   - If hold_time >= 10 minutes AND profit < 0.15% → Move SL to entry + 2 points (position remains open, no exit_reason set)

3. **Stop Loss Check:**
   - If current price hits stop_loss → Close position, exit_reason = "stop_loss"

4. **Momentum Reversal Check:**
   - Fetch last 3 M1 candles
   - If 3 consecutive opposite candles (red for long, green for short) → Close position, exit_reason = "momentum_reversal"

5. **Breakeven Protection:**
   - If profit >= 0.15% AND stop_loss < entry_price (for long) → Move SL to entry + 2 points
   - If profit >= 0.15% AND stop_loss > entry_price (for short) → Move SL to entry - 2 points

6. **Partial Exit Logic:**
   - If profit >= 0.20% AND no partial exit yet → Close 50%, move SL to entry
   - If profit >= 0.35% AND only 50% closed → Close additional 30%, let 20% run to TP

### Circuit Breaker Algorithm

**Halt Evaluation (Any condition triggers halt):**

1. **Consecutive Losses:**
   - Get last 3 trades
   - If all 3 have pnl < 0 → Halt, reason = "3_consecutive_losses"

2. **Recent Loss Rate:**
   - Get last 7 trades
   - Count losses (pnl < 0)
   - If losses >= 5 → Halt, reason = "5_losses_in_7_trades"

3. **Daily Drawdown:**
   - Calculate daily P&L: sum of all trades today
   - If daily_pnl <= -3% of starting equity → Halt, reason = "daily_drawdown_3pct"

4. **Stop-Out Rate:**
   - Get last 5 trades
   - Count stop_loss exits
   - If stop_loss_exits >= 4 → Halt, reason = "4_stopouts_in_5_trades"

**Graduated Response:**
- After 1 loss: Increase confidence threshold from default to 70%
- After 2 losses: Reduce risk to 0.3%, confidence to 75%, tighten spread filter by 20%
- After 3 losses: Halt for 60 minutes, require manual review or winning trade

**Reset Conditions:**
- 2 consecutive wins (pnl > 0) → Reset to default parameters
- Single win with >1.5R profit → Reset to default parameters
- Manual reset after session analysis

### Session Management Algorithm

**Time Window Classification (GMT):**

1. **Prime Sessions (risk_multiplier = 1.0):**
   - 08:00-09:30: London Open
   - 13:00-15:00: London-NY Overlap (BEST)
   - 14:30-15:30: NY Data Releases

2. **Acceptable Sessions (risk_multiplier = 0.7-0.8):**
   - 09:30-13:00: London Morning
   - 15:30-17:00: NY Afternoon

3. **Closed Sessions (no trading):**
   - 00:00-07:00: Asian Session
   - 18:00-24:00: Evening wind-down
   - Friday after 16:00: Weekend positioning

**Implementation:**
- Convert current time to GMT
- Check if current time falls within any enabled window
- Return session_type and risk_multiplier
- If no window active, reject signal before risk validation

### Volatility Filtering Algorithm

**ATR Validation:**

1. Calculate ATR14 on M5 candles
2. Calculate 20-period ATR average
3. Check conditions:
   - If ATR < 6.0 points → Reject (market too choppy/ranging)
   - If ATR > 12.0 points → Reject (too volatile for tight stops)
   - If ATR > 1.8 × ATR_average → Reject (spike, likely news event)
4. Optimal range: 8-11 points (accept with full confidence)
5. If ATR in 6-8 or 11-12 range → Accept but reduce confidence by 10%

## Implementation Phases

### Phase 1: Data Layer and Foundation
**Purpose:** Establish core infrastructure, data structures, and database schema.

**Tasks:**
1. Create project structure and `requirements.txt` (MetaTrader5, pyyaml, sqlite3, logging)
2. Implement `src/utils/types.py` with all type definitions
3. Implement `src/utils/logger.py` with structured logging and rotation
4. Implement `config/config_loader.py` and create `config/config.yaml` template
5. Implement `src/analytics/database.py` with SQLite schema (signals, trades, sessions, circuit_breaker_events tables)
6. Create `.env.example` with MT5 credentials template

**Deliverables:**
- All type definitions
- Config system with YAML loading
- Database schema and operations
- Logging infrastructure

### Phase 2A: Market Data Engine
**Purpose:** Connect to MT5, fetch market data, calculate technical indicators.

**Tasks:**
1. Implement `src/market_data/mt5_connector.py` (connection, data fetching, account info)
2. Implement `src/market_data/candle_processor.py` (OHLC validation, data cleaning)
3. Implement `src/market_data/indicators.py` (EMA, RSI, ATR, swing points, trend detection)

**Dependencies:** Phase 1

**Deliverables:**
- MT5 connection and data fetching
- All indicator calculations
- Market data validation

### Phase 2B: Signal Generator
**Purpose:** Analyze market structure and momentum to generate trading signals.

**Tasks:**
1. Implement `src/signals/structure_analyzer.py` (M5 structure identification)
2. Implement `src/signals/momentum_analyzer.py` (M1 momentum confirmation)
3. Implement `src/signals/signal_generator.py` (combines analysis, generates signals with confidence)

**Dependencies:** Phase 2A

**Deliverables:**
- Complete signal generation pipeline
- Structure Break Momentum algorithm implementation

### Phase 2C: Risk Management System
**Purpose:** Validate signals, calculate position sizes, implement circuit breakers.

**Tasks:**
1. Implement `src/risk/position_sizer.py` (lot size calculation with constraints)
2. Implement `src/risk/risk_validator.py` (pre-trade validation: spread, ATR, equity)
3. Implement `src/risk/circuit_breaker.py` (halt conditions, graduated response, reset logic)

**Dependencies:** Phase 2A, Phase 2B

**Deliverables:**
- Position sizing with risk % calculation
- Pre-trade validation
- Circuit breaker system

### Phase 2D: Execution Engine
**Purpose:** Execute trades via MT5 API with sub-2-second latency.

**Tasks:**
1. Implement `src/execution/order_validator.py` (final order parameter validation)
2. Implement `src/execution/order_executor.py` (MT5 order placement, TP/SL calculation, slippage handling)

**Dependencies:** Phase 2C

**Deliverables:**
- Order execution via MT5 API
- Take profit calculation with R:R ratios
- Execution latency optimization

### Phase 2E: Position Management
**Purpose:** Monitor open positions and execute multi-layered exit strategy.

**Tasks:**
1. Implement `src/position/exit_strategy.py` (exit hierarchy algorithm)
2. Implement `src/position/position_manager.py` (position monitoring, partial exits, breakeven protection, force closes)

**Dependencies:** Phase 2D, Phase 2A

**Deliverables:**
- Real-time position monitoring
- Multi-layered exit logic
- Partial exit and breakeven protection

### Phase 2F: Session and Volatility Management
**Purpose:** Filter trades based on time windows and market volatility.

**Tasks:**
1. Implement `src/session/session_manager.py` (GMT time windows, session classification, risk multipliers)
2. Implement `src/session/volatility_filter.py` (ATR validation, spike detection, market condition filtering)

**Dependencies:** Phase 2A

**Deliverables:**
- Time-based trading window filtering
- ATR-based volatility gating
- Session risk adjustment

### Phase 2G: Analytics and Integration
**Purpose:** Record all activity, track performance, integrate all modules.

**Tasks:**
1. Implement `src/analytics/trade_recorder.py` (signal and trade recording)
2. Implement `src/analytics/performance_tracker.py` (metrics calculation, reporting)
3. Implement `src/main.py` (orchestration, 30-second execution loop, module integration)
4. Create monitoring output (current position, equity, circuit breaker status, last 5 signals)

**Dependencies:** All previous phases

**Deliverables:**
- Complete analytics tracking
- Main execution loop
- System integration and monitoring

## Configuration Requirements

### Environment Variables (`.env`)
- `MT5_LOGIN`: MetaTrader 5 account number
- `MT5_PASSWORD`: MetaTrader 5 password
- `MT5_SERVER`: MT5 broker server name
- `MT5_SYMBOL`: Trading symbol (default: XAUUSD)
- `ENVIRONMENT`: development|staging|production

### Config File (`config/config.yaml`)
- Risk parameters: risk_per_trade (0.5%), stop_loss_range (0.25-0.50%), risk_reward_ratio (1.0-2.0)
- Trading sessions: enable/disable specific windows
- Circuit breaker thresholds: consecutive losses, daily drawdown limit
- Execution settings: cycle_interval (30 seconds), max_concurrent_positions (1), slippage_tolerance (2 points)
- Logging: log_level, log_directory, rotation settings

## Performance Requirements

- **Execution Latency:** Sub-2-second from signal generation to order placement
  - Market data fetch: <500ms
  - Signal generation: <800ms
  - Risk validation: <200ms
  - Order execution: <500ms
- **Data Refresh:** 30-second execution cycle
- **Database:** SQLite with daily trade history (30+ days retention)
- **Logging:** Structured logs with daily rotation, 30-day retention, compression after 7 days

## Integration Points

- **MetaTrader 5 API:** Primary integration for market data and order execution
- **SQLite Database:** Local storage for trade history and analytics
- **YAML Configuration:** User-configurable parameters
- **Environment Variables:** Sensitive credentials (MT5 login)

## Notes

- System is standalone Python application (no web dependencies)
- Single-threaded execution pipeline (no multi-agent complexity)
- Pure technical analysis (no AI for signal generation)
- All times in GMT
- Point value for XAUUSD: $0.01 per point per 0.01 lot (verify with broker)
- Paper trading mode available for development environment

